[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Methods for Structural Microeconometrics",
    "section": "",
    "text": "Welcome to this course! Find details on the syllabus here, and check out the menu to find other materials."
  },
  {
    "objectID": "index.html#topics",
    "href": "index.html#topics",
    "title": "Methods for Structural Microeconometrics",
    "section": "Topics",
    "text": "Topics\n\nIdentification, Credible Inference, and Marschak’s Maxim\n2024 is the last year I will make this topic a part of the course.\nWe formally define identification and discuss (via examples) what people really mean when they talk about identification and credible inference. We use the Generalized Roy Model to compare identification via functional form to nonparametric identification.\nWe introduce Marschak’s Maxim as a guide for doing empirical model-based research.\n\nReading\nThe two survey articles by Keane (2010) (link) and Angrist and Pischke (2010) (link) - although aging - provide two important perspectives on the issues of credible inference in economics. Low and Meghir (2017) provide a nice review of the advantages of the structural approach.\nThe original paper by Marschak (1953) may be of interest. Heckman and Vytlacil (2007) provide a nice discussion of Marschak’s Maxim in the context of policy evaluation. They introduce (Heckman and Vytlacil 2005; Carneiro, Heckman, and Vytlacil 2011) the Marginal Treatment Effect as a tool for thinking about quasi-experimental estimators and policy evaluation.\n\n\n\nDynamic Discrete Choice\nWe introduce the dynamic discrete choice model and briefly discuss identification when all persistent state variables are observed. We review some of the basics of discrete choice such as the generalized extreme value distribution, which produces tractable choice probabilities with relatively flexible cross-price elasticities.\n\nReading\nThe main example that we work with throughout the course can be found in Mullins (2022) (pdf).\nRust (1987) is the canonical example demonstrating estimation of dynamic discrete choice models with maximum likelihood and a nested solution method.\nWe show that if one can directly estimate choice probabilities, several tractable approaches produce estimates of structural parameters without repeatedly solving the model. These include Hotz and Miller (1993), Aguirregabiria and Mira (2002), Aguirregabiria and Mira (2007), Pesendorfer and Schmidt-Dengler (2008), and Arcidiacono and Miller (2011). We will review these methods and why they are not appropriate to use in Mullins (2022).\n\n\n\nEstimation of Dynamic Models with Unobserved Heterogeneity\nUsing Mullins (2022) as an example, we talk about the inferential pitfalls that can occur when models fail to account for unobserved heterogeneity. We briefly discuss how this can depend on estimation approaches and sources of identification.\nWe review methods for estimation of dynamic models, including the Expectation-Maximization algorithm (EM) (see, e.g. Arcidiacono and Miller (2011)) and the clustering approach of Bonhomme and Manresa (2015). We review practical considerations for these approaches and introduce the Forward-Back algorithm for implementing EM in hidden Markov Models with time-varying unobserved state variables. We introduce a sparse matrix implementation of this algorithm.\n\n\nIdentification of Dynamic Models with Unobserved Heterogeneity\nWe discuss how either panel data or instrumental variables can facilitate identification of models with unobserved heterogeneity, and briefly review identification results for finite mixtures in panel data settings due to Kasahara and Shimotsu (2009) and Bonhomme, Jochmans, and Robin (2016). Berry and Compiani (2023) analyze identification and estimation of dynamic models with persistent heterogeneity using instrumental variables."
  },
  {
    "objectID": "index.html#assessment",
    "href": "index.html#assessment",
    "title": "Methods for Structural Microeconometrics",
    "section": "Assessment",
    "text": "Assessment\nThere will be 7 problem sets. Your best 5 of these 7 problem sets will be worth 20%. Hence, you can skip two if you want.\nHere is the proposed timeline of due dates. Submissions must be made through Canvas as a notebook (e.g. jupyter or quarto) formatted to html with printed output.\n\n\n\nAssignment\nDue Date\n\n\n\n\nAssignment 1\nMarch 22\n\n\nAssignment 2\nMarch 29\n\n\nAssignment 3\nApril 5\n\n\nAssignment 4\nApril 12\n\n\nAssignment 5\nApril 19\n\n\nAssignment 6\nApril 26\n\n\nAssignment 7\nMay 3"
  },
  {
    "objectID": "index.html#office-hours",
    "href": "index.html#office-hours",
    "title": "Methods for Structural Microeconometrics",
    "section": "Office Hours",
    "text": "Office Hours\nI will provide a link on Canvas to sign up for my weekly office hours."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "assignments/Assignment-1.html",
    "href": "assignments/Assignment-1.html",
    "title": "Assignment 1",
    "section": "",
    "text": "Here is code to load the dataset and do a little cleaning / filtering.\nThe sample is all mothers in the PSID who are unmarried at the time of their first childbirth.\n\nusing CSV, DataFrames, DataFramesMeta\n\ndata = @chain begin\n    CSV.read(\"../children-cash-transfers/data/MainPanelFile.csv\",DataFrame,missingstring = \"NA\")\n    @select :MID :year :wage :hrs :earn :SOI :CPIU :WelfH :FSInd\n    @subset :year.&gt;=1985 :year.&lt;=2010\n    @transform :AFDC = :WelfH.&gt;0\n    @rename :FS = :FSInd\n    end\n\n89747×10 DataFrame89722 rows omitted\n\n\n\nRow\nMID\nyear\nwage\nhrs\nearn\nSOI\nCPIU\nWelfH\nFS\nAFDC\n\n\n\nInt64\nInt64\nFloat64?\nInt64?\nFloat64?\nInt64\nFloat64\nFloat64?\nInt64?\nBool?\n\n\n\n\n1\n4031\n1990\nmissing\nmissing\nmissing\n43\n0.758793\n0.0\n0\nfalse\n\n\n2\n4031\n1991\nmissing\nmissing\nmissing\n43\n0.790786\n0.0\n0\nfalse\n\n\n3\n4031\n1992\nmissing\nmissing\nmissing\n43\n0.814835\n0.0\n1\nfalse\n\n\n4\n4031\n1993\nmissing\nmissing\nmissing\n43\n0.839034\n0.0\n0\nfalse\n\n\n5\n4031\n1994\nmissing\n0\n0.0\n43\n0.860812\n1704.0\n1\ntrue\n\n\n6\n4031\n1995\nmissing\n0\n0.0\n43\n0.88496\n1704.0\n1\ntrue\n\n\n7\n4031\n1996\nmissing\n0\n0.0\n43\n0.910948\n1704.0\n1\ntrue\n\n\n8\n4031\n1997\nmissing\nmissing\nmissing\n43\n0.932244\nmissing\nmissing\nmissing\n\n\n9\n4031\n1998\nmissing\n0\n0.0\n43\n0.946664\n0.0\n1\nfalse\n\n\n10\n4031\n1999\nmissing\nmissing\nmissing\n43\n0.967426\nmissing\nmissing\nmissing\n\n\n11\n4031\n2000\n3.33333\n120\n400.0\n43\n1.0\n0.0\n0\nfalse\n\n\n12\n4031\n2001\nmissing\nmissing\nmissing\n43\n1.02817\nmissing\nmissing\nmissing\n\n\n13\n4031\n2002\nmissing\n0\n0.0\n43\n1.04457\n0.0\n0\nfalse\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n89736\n9308002\n1999\nmissing\nmissing\nmissing\n39\n0.967426\nmissing\nmissing\nmissing\n\n\n89737\n9308002\n2000\nmissing\nmissing\nmissing\n39\n1.0\nmissing\nmissing\nmissing\n\n\n89738\n9308002\n2001\nmissing\nmissing\nmissing\n39\n1.02817\nmissing\nmissing\nmissing\n\n\n89739\n9308002\n2002\nmissing\nmissing\nmissing\n39\n1.04457\nmissing\nmissing\nmissing\n\n\n89740\n9308002\n2003\nmissing\nmissing\nmissing\n39\n1.06857\nmissing\nmissing\nmissing\n\n\n89741\n9308002\n2004\nmissing\nmissing\nmissing\n39\n1.09708\nmissing\nmissing\nmissing\n\n\n89742\n9308002\n2005\nmissing\nmissing\nmissing\n39\n1.13401\nmissing\nmissing\nmissing\n\n\n89743\n9308002\n2006\nmissing\nmissing\nmissing\n39\n1.17054\nmissing\nmissing\nmissing\n\n\n89744\n9308002\n2007\nmissing\nmissing\nmissing\n39\n1.20414\nmissing\nmissing\nmissing\n\n\n89745\n9308002\n2008\nmissing\nmissing\nmissing\n39\n1.25008\nmissing\nmissing\nmissing\n\n\n89746\n9308002\n2009\nmissing\nmissing\nmissing\n39\n1.24608\nmissing\nmissing\nmissing\n\n\n89747\n9308002\n2010\nmissing\nmissing\nmissing\n39\n1.26647\nmissing\nmissing\nmissing\n\n\n\n\n\n\nYou may be unfamiliar with some of these commands, which make use of DataFrames and DataFramesMeta. In particular, think of the @chain macro as a way to compose functions. So for example:\n\nd1 = @chain d2 begin\n    func1(x)\n    func2(y)\n    func3(z)\nend\n\nis equivalent to calling:\n\nd1 = func3(func2(func1(d2,x),y),z)\n\nIf you want to understand better, google is your friend!"
  },
  {
    "objectID": "assignments/Assignment-1.html#setup-loading-the-data",
    "href": "assignments/Assignment-1.html#setup-loading-the-data",
    "title": "Assignment 1",
    "section": "",
    "text": "Here is code to load the dataset and do a little cleaning / filtering.\nThe sample is all mothers in the PSID who are unmarried at the time of their first childbirth.\n\nusing CSV, DataFrames, DataFramesMeta\n\ndata = @chain begin\n    CSV.read(\"../children-cash-transfers/data/MainPanelFile.csv\",DataFrame,missingstring = \"NA\")\n    @select :MID :year :wage :hrs :earn :SOI :CPIU :WelfH :FSInd\n    @subset :year.&gt;=1985 :year.&lt;=2010\n    @transform :AFDC = :WelfH.&gt;0\n    @rename :FS = :FSInd\n    end\n\n89747×10 DataFrame89722 rows omitted\n\n\n\nRow\nMID\nyear\nwage\nhrs\nearn\nSOI\nCPIU\nWelfH\nFS\nAFDC\n\n\n\nInt64\nInt64\nFloat64?\nInt64?\nFloat64?\nInt64\nFloat64\nFloat64?\nInt64?\nBool?\n\n\n\n\n1\n4031\n1990\nmissing\nmissing\nmissing\n43\n0.758793\n0.0\n0\nfalse\n\n\n2\n4031\n1991\nmissing\nmissing\nmissing\n43\n0.790786\n0.0\n0\nfalse\n\n\n3\n4031\n1992\nmissing\nmissing\nmissing\n43\n0.814835\n0.0\n1\nfalse\n\n\n4\n4031\n1993\nmissing\nmissing\nmissing\n43\n0.839034\n0.0\n0\nfalse\n\n\n5\n4031\n1994\nmissing\n0\n0.0\n43\n0.860812\n1704.0\n1\ntrue\n\n\n6\n4031\n1995\nmissing\n0\n0.0\n43\n0.88496\n1704.0\n1\ntrue\n\n\n7\n4031\n1996\nmissing\n0\n0.0\n43\n0.910948\n1704.0\n1\ntrue\n\n\n8\n4031\n1997\nmissing\nmissing\nmissing\n43\n0.932244\nmissing\nmissing\nmissing\n\n\n9\n4031\n1998\nmissing\n0\n0.0\n43\n0.946664\n0.0\n1\nfalse\n\n\n10\n4031\n1999\nmissing\nmissing\nmissing\n43\n0.967426\nmissing\nmissing\nmissing\n\n\n11\n4031\n2000\n3.33333\n120\n400.0\n43\n1.0\n0.0\n0\nfalse\n\n\n12\n4031\n2001\nmissing\nmissing\nmissing\n43\n1.02817\nmissing\nmissing\nmissing\n\n\n13\n4031\n2002\nmissing\n0\n0.0\n43\n1.04457\n0.0\n0\nfalse\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n89736\n9308002\n1999\nmissing\nmissing\nmissing\n39\n0.967426\nmissing\nmissing\nmissing\n\n\n89737\n9308002\n2000\nmissing\nmissing\nmissing\n39\n1.0\nmissing\nmissing\nmissing\n\n\n89738\n9308002\n2001\nmissing\nmissing\nmissing\n39\n1.02817\nmissing\nmissing\nmissing\n\n\n89739\n9308002\n2002\nmissing\nmissing\nmissing\n39\n1.04457\nmissing\nmissing\nmissing\n\n\n89740\n9308002\n2003\nmissing\nmissing\nmissing\n39\n1.06857\nmissing\nmissing\nmissing\n\n\n89741\n9308002\n2004\nmissing\nmissing\nmissing\n39\n1.09708\nmissing\nmissing\nmissing\n\n\n89742\n9308002\n2005\nmissing\nmissing\nmissing\n39\n1.13401\nmissing\nmissing\nmissing\n\n\n89743\n9308002\n2006\nmissing\nmissing\nmissing\n39\n1.17054\nmissing\nmissing\nmissing\n\n\n89744\n9308002\n2007\nmissing\nmissing\nmissing\n39\n1.20414\nmissing\nmissing\nmissing\n\n\n89745\n9308002\n2008\nmissing\nmissing\nmissing\n39\n1.25008\nmissing\nmissing\nmissing\n\n\n89746\n9308002\n2009\nmissing\nmissing\nmissing\n39\n1.24608\nmissing\nmissing\nmissing\n\n\n89747\n9308002\n2010\nmissing\nmissing\nmissing\n39\n1.26647\nmissing\nmissing\nmissing\n\n\n\n\n\n\nYou may be unfamiliar with some of these commands, which make use of DataFrames and DataFramesMeta. In particular, think of the @chain macro as a way to compose functions. So for example:\n\nd1 = @chain d2 begin\n    func1(x)\n    func2(y)\n    func3(z)\nend\n\nis equivalent to calling:\n\nd1 = func3(func2(func1(d2,x),y),z)\n\nIf you want to understand better, google is your friend!"
  },
  {
    "objectID": "assignments/Assignment-1.html#question-1",
    "href": "assignments/Assignment-1.html#question-1",
    "title": "Assignment 1",
    "section": "Question 1",
    "text": "Question 1\nCalculate average welfare participation (AFDC) by year and plot it. What do you think happened with welfare participation in 1996 and after? If you don’t know the historical context, a quick search online or a read of this paper should help you out.\nIf you are new to julia, here is average hours calculated and plotted to get you started.\n\nusing StatsPlots, Statistics\n\nd = @chain data begin\n    groupby(:year)\n    @combine :Hours = mean(skipmissing(:hrs))\n    @subset .!isnan.(:Hours)\nend\n\n@df d plot(:year,:Hours, legend = :none, linewidth = 2)\nxlabel!(\"Year\")\nylabel!(\"Average Welfare Participation\")"
  },
  {
    "objectID": "assignments/Assignment-1.html#question-2",
    "href": "assignments/Assignment-1.html#question-2",
    "title": "Assignment 1",
    "section": "Question 2",
    "text": "Question 2\nNow write code to\n\nDeflate earnings by CPI (CPIU).\nCalculate annual average earnings for each individual (identified by MID).\nDrop individuals with fewer than 10 years of data.\nCategorize individuals by whether their average earnings is below or above the median across individuals.\nPlot average participation in each year for individuals in each of these two categories.\n\nDo you think this pattern is likely to be generated by a model without persistent unobserved heterogeneity? No strictly correct answer here, just curious to read what you think.\nIn case it helps, here is code for the first three steps. You could edit this to add additional operations to the chain or work with d directly.\n\nd = @chain data begin\n    @transform :earn = :earn ./ :CPIU\n    groupby(:MID)\n    @combine :T = sum(.!ismissing.(:earn)) :earn = mean(skipmissing(:earn)) \n    @subset :T .&gt;= 10\nend\n\n1089×3 DataFrame1064 rows omitted\n\n\n\nRow\nMID\nT\nearn\n\n\n\nInt64\nInt64\nFloat64\n\n\n\n\n1\n4031\n10\n40.0\n\n\n2\n4179\n16\n6089.12\n\n\n3\n7030\n11\n4500.53\n\n\n4\n41007\n12\n16147.7\n\n\n5\n41008\n11\n0.0\n\n\n6\n45030\n11\n14374.3\n\n\n7\n45031\n11\n17693.5\n\n\n8\n47031\n11\n15946.7\n\n\n9\n84005\n18\n30769.6\n\n\n10\n105030\n14\n4633.61\n\n\n11\n106173\n13\n17714.4\n\n\n12\n122173\n13\n56275.2\n\n\n13\n126003\n19\n6705.08\n\n\n⋮\n⋮\n⋮\n⋮\n\n\n1078\n6843006\n19\n1805.93\n\n\n1079\n6843173\n19\n5005.44\n\n\n1080\n6845005\n19\n19795.4\n\n\n1081\n6849005\n19\n2450.55\n\n\n1082\n6849188\n15\n23259.0\n\n\n1083\n6853003\n19\n4856.42\n\n\n1084\n6862005\n11\n18899.4\n\n\n1085\n6862008\n19\n26634.8\n\n\n1086\n6864002\n19\n8695.92\n\n\n1087\n6864003\n18\n13627.5\n\n\n1088\n6867013\n13\n389.097\n\n\n1089\n6872171\n17\n3294.07"
  },
  {
    "objectID": "assignments/Assignment-1.html#question-3",
    "href": "assignments/Assignment-1.html#question-3",
    "title": "Assignment 1",
    "section": "Question 3",
    "text": "Question 3\nThis question is to familiarize you with the module Tranfers.jl which will enable you to calculate post-tax and transfer income for individuals given their earnings, non-labor income, state, year, and family size. The function budget in this module takes the arguments:\n\nE: monthly earnings (either real or nominal)\nN: monthly non-labor income (real or nominal)\nSOI: the SOI code for state of residence\nyear: calendar year\nnum_kids: the number of children\ncpi: set to 1. if E and N are nominal\np: equal to 0 if no programs, 1 if food stamps, 2 if food stamps + welfare.\n\nFor example the function call:\n\nTransfers.budget(500.,0.,23,2000,2,1.,2)\n\ncalculates net income for a mother in Michigan (SOI code 23) with 2 kids, nominal labor income of $500 a month in the year 2000, and no non-labor income.\n\ninclude(\"../children-cash-transfers/src/Transfers.jl\")\n\nTransfers.budget(500.,0.,23,2000,2,1.,2)\n\n978.5408333333334\n\n\nCreate a graph that represents total net transfers for a single mother with two kids in the years 1990 and 2000 and in the states of Mississippi and New York. Depict these transfers as a function of earnings between the values of 0 and $1,000 a month (nominal). You can assume that all households are receiving both food stamps and welfare.\nWhat do you make of the differences in these transfers across states and over time?"
  }
]