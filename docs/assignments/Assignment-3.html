<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.539">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Econ8502 - Assignment 3 - Solving the Dynamic Program</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Econ8502</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-assignments" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Assignments</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-assignments">    
        <li>
    <a class="dropdown-item" href="../assignments/Assignment-1.html">
 <span class="dropdown-text">Assignment 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../assignments/Assignment-2.html">
 <span class="dropdown-text">Assignment 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../assignments/Assignment-3.html">
 <span class="dropdown-text">Assignment 3 - Solving the Dynamic Program</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#assignment-3---solving-the-dynamic-program" id="toc-assignment-3---solving-the-dynamic-program" class="nav-link active" data-scroll-target="#assignment-3---solving-the-dynamic-program">Assignment 3 - Solving the Dynamic Program</a>
  <ul class="collapse">
  <li><a href="#source-code-for-the-model" id="toc-source-code-for-the-model" class="nav-link" data-scroll-target="#source-code-for-the-model">Source code for the model</a>
  <ul class="collapse">
  <li><a href="#setting-exogenous-state-variables" id="toc-setting-exogenous-state-variables" class="nav-link" data-scroll-target="#setting-exogenous-state-variables">Setting exogenous state variables</a></li>
  <li><a href="#nested-logit-probabilities" id="toc-nested-logit-probabilities" class="nav-link" data-scroll-target="#nested-logit-probabilities">Nested Logit Probabilities</a></li>
  <li><a href="#indexing-the-state" id="toc-indexing-the-state" class="nav-link" data-scroll-target="#indexing-the-state">Indexing the State</a></li>
  <li><a href="#transition-probabilities" id="toc-transition-probabilities" class="nav-link" data-scroll-target="#transition-probabilities">Transition Probabilities</a></li>
  </ul></li>
  <li><a href="#part-1" id="toc-part-1" class="nav-link" data-scroll-target="#part-1">Part 1</a></li>
  <li><a href="#part-2" id="toc-part-2" class="nav-link" data-scroll-target="#part-2">Part 2</a></li>
  <li><a href="#part-3" id="toc-part-3" class="nav-link" data-scroll-target="#part-3">Part 3</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Assignment 3 - Solving the Dynamic Program</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="assignment-3---solving-the-dynamic-program" class="level1">
<h1>Assignment 3 - Solving the Dynamic Program</h1>
<section id="source-code-for-the-model" class="level2">
<h2 class="anchored" data-anchor-id="source-code-for-the-model">Source code for the model</h2>
<p>Since you only have a week, I’m not going to make you code every piece of the model solution. The folder <code>/children-cash-transfers/src</code> contains:</p>
<ul>
<li>functions to calculate utility and net income from each choice</li>
<li>an indexing rule that maps choices to hours and participation</li>
<li>the structure for the nested logit and code to calculate nested logit probabilities and inclusive values</li>
<li>functions to calculate transition probabilities</li>
<li>code to define a default set of parameters and hyperparameters (the number of wage shocks, number of types, etc)</li>
</ul>
<p>If you have cloned the course git repo, you can load all of this source code as follows:</p>
<div id="cell-2" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">include</span>(<span class="st">"../children-cash-transfers/src/model.jl"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>plain_logit (generic function with 1 method)</code></pre>
</div>
</div>
<p>It will help to quickly explain some of this, but I recommend you read the code carefully since I won’t explain the functions in depth.</p>
<section id="setting-exogenous-state-variables" class="level3">
<h3 class="anchored" data-anchor-id="setting-exogenous-state-variables">Setting exogenous state variables</h3>
<p>Recall that in the model there are only three state variables to track: (1) the individual’s type (<span class="math inline">\(k\)</span>); (2) the wage shock (<span class="math inline">\(\varepsilon\)</span>); and (3) cumulative welfare use (<span class="math inline">\(\omega\)</span>). Below we define a struct called <code>model_data</code> that contains all of the exogenous state variables that are taken as given for each individual in the data. The struct is defined in <code>/children-cash-transfers/src/model.jl</code>, but we repeat the definition here:</p>
<div id="cell-4" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> model_data</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    T<span class="op">::</span><span class="dt">Int64 </span><span class="co">#&lt;- length of problem</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    y0<span class="op">::</span><span class="dt">Int64 </span><span class="co">#&lt;- year to begin problem</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    age0<span class="op">::</span><span class="dt">Int64 </span><span class="co"># &lt;- mother's age at start of problem</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    SOI<span class="op">::</span><span class="dt">Vector{Int64} </span><span class="co">#&lt;- state SOI in each year</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    num_kids<span class="op">::</span><span class="dt">Vector{Int64} </span><span class="co">#&lt;- number of kids in household that are between age 0 and 17</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    TotKids<span class="op">::</span><span class="dt">Int64 </span><span class="co">#&lt;- indicares the total number of children that the mother will have over the available panel</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    age_kid<span class="op">::</span><span class="dt">Matrix{Int64} </span><span class="co">#&lt; age_kid[f,t] is the age of child f at time t. Will be negative if child not born yet.</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    cpi<span class="op">::</span><span class="dt">Vector{Float64} </span><span class="co">#&lt;- cpi</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    R<span class="op">::</span><span class="dt">Vector{Int64} </span><span class="co">#&lt;- indicates if work requirement in time t</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    Kω<span class="op">::</span><span class="dt">Int64 </span><span class="co">#&lt;- indicates length of time limit once introduced</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    TL<span class="op">::</span><span class="dt">Vector{Bool} </span><span class="co">#&lt;- indicating that time limit is in place</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Eventually we will have one of these objects for every mother we observe in the data, and we’ll solve the resulting dynamic program for each of them. To test our functions below we can create a test version of this struct as well as some default parameters:</p>
<div id="cell-6" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>md <span class="op">=</span> <span class="fu">test_model</span>()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">pars</span>(<span class="fl">2</span>,<span class="fl">6</span>) <span class="co">#&lt;- set Kτ = 2 and Kε = 5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="nested-logit-probabilities" class="level3">
<h3 class="anchored" data-anchor-id="nested-logit-probabilities">Nested Logit Probabilities</h3>
<p>The function <code>nested_logit</code> takes the value of each choice <code>vj</code> and fills log-choice probabilities into a pre-allocated vector <code>logP</code>. It also returns the inclusive value (the “emax” or continuation value). The input <span class="math inline">\(B=(B_1,B_2,...,B_L)\)</span> specifies the partitions in each layer of the tree, while the input <span class="math inline">\(C\)</span> reports the final choices that are ultimately contained in each node in each layer. By definition, at the highest layer, the partition takes the trivial form <span class="math inline">\(B_L=\{\{1,2,...K_L\}\}\)</span> where <span class="math inline">\(K_L\)</span> is the number of partitions in layer <span class="math inline">\(L-1\)</span>. Similarly at the lowest layer, <span class="math inline">\(C_{1}\)</span> must take the form <span class="math inline">\(C_{1} = \{\{1\},\{2\},...,\{J\}\}\)</span>. For this model with three participation choices that lead into an extensive marginal labor supply choice, the structure is:</p>
<div id="cell-8" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>B₁ <span class="op">=</span> [[<span class="fl">1</span>,<span class="fl">2</span>],[<span class="fl">3</span>,<span class="fl">4</span>],[<span class="fl">5</span>,<span class="fl">6</span>]]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>C₁ <span class="op">=</span> [[<span class="fl">1</span>,],[<span class="fl">2</span>,],[<span class="fl">3</span>,],[<span class="fl">4</span>,],[<span class="fl">5</span>,],[<span class="fl">6</span>,]]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>B₂ <span class="op">=</span> [[<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>]]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>C₂ <span class="op">=</span> [[<span class="fl">1</span>,<span class="fl">2</span>],[<span class="fl">3</span>,<span class="fl">4</span>],[<span class="fl">5</span>,<span class="fl">6</span>]]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> (B₁,B₂)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> (C₁,C₂)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is defined in <code>src/model/choices.jl</code>. This is for your understanding, but these inputs are all given to you so you can use the function naively if that is all your time allows for.</p>
</section>
<section id="indexing-the-state" class="level3">
<h3 class="anchored" data-anchor-id="indexing-the-state">Indexing the State</h3>
<p>You may find the following objects useful for iterating over the state variables. Let <span class="math inline">\(k_{\tau}\in\{1,...,K_{\tau}\}\)</span> index latent types, let <span class="math inline">\(k_{\varepsilon}\in\{1,...,K_{\varepsilon}\}\)</span> index wage shocks, and let <span class="math inline">\(k_{\omega} = \omega+1\)</span> index cumulative time use. The total size of the state space is <span class="math inline">\(K=K_\tau\times K_{\varepsilon} \times K_{\omega}\)</span>.</p>
<p>One way to do simple indexing is to just work with multi-dimensional arrays and build this into every function. However if you want to add state variables later on it will make it cumbersome to change. Another option is to use <code>LinearIndices</code> objects and their converse, <code>CartesianIndices</code>.</p>
<p>Here’s a demonstration:</p>
<div id="cell-10" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Hypothetical state space dimensions:</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>Kε <span class="op">=</span> <span class="fl">5</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>Kτ <span class="op">=</span> <span class="fl">5</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>Kω <span class="op">=</span> <span class="fl">6</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>k_idx <span class="op">=</span> <span class="fu">LinearIndices</span>((Kτ,Kε,Kω))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>k_inv <span class="op">=</span> <span class="fu">CartesianIndices</span>(k_idx)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co"># To get the aggregate index k, call:</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> k_idx[<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">2</span>]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="pp">@show</span> k</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Then if we have k we can work back with:</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>k_tuple <span class="op">=</span> <span class="fu">Tuple</span>(k_inv[k])</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="pp">@show</span> k_tuple</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>k = 37
k_tuple = (2, 3, 2)</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>(2, 3, 2)</code></pre>
</div>
</div>
<p>So when iterating, you could think about passing around state indices along with instances of these linear and cartesian indices that allow you to convert back and forth.</p>
</section>
<section id="transition-probabilities" class="level3">
<h3 class="anchored" data-anchor-id="transition-probabilities">Transition Probabilities</h3>
<p>In the paper, wage shocks are parameterized with a single parameter <span class="math inline">\(\pi_{W}\)</span> that dictates the probability that an individual remains in the same place on the grid space, with symmetric probabilities of moving up or down. The function <code>fε</code> in <code>states_transitions.jl</code> takes the current wage shock <code>kε</code> and the total number of shocks <code>Kε</code>, along with <code>πW</code> and returns two tuples. The first tuple is the set of grid points that are possible and the second is the probability of being in each of those points.</p>
<p>For example:</p>
<div id="cell-12" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fε</span>(<span class="fl">3</span>,<span class="fl">5</span>,<span class="fl">0.9</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>((2, 3, 4), (0.04999999999999999, 0.9, 0.04999999999999999))</code></pre>
</div>
</div>
<p>So the function is telling me that when I’m in state 3 I can move to states 3, 4, or 5 next period with probabilities (0.05,0.9,0.05). When we are at the bottom or the top of the grid space, the probabilities are slightly different:</p>
<div id="cell-14" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fε</span>(<span class="fl">1</span>,<span class="fl">5</span>,<span class="fl">0.9</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>((1, 2), (0.04999999999999999, 0.95))</code></pre>
</div>
</div>
<p>We could have alternatively just written the transition probabilities into a matrix, but this approach essentially limits us to points with positive probabilities and will simplify iteration.</p>
</section>
</section>
<section id="part-1" class="level2">
<h2 class="anchored" data-anchor-id="part-1">Part 1</h2>
<p>Write a function <code>calc_vj</code> that calculates the choice-specific value (i.e.&nbsp;the deterministic value of the choice) of a particular choice <span class="math inline">\(j\)</span> in a particular time period <span class="math inline">\(t\)</span> given the state and other exogenous variables. If you are confident you can code this however you like, but given the existing setup you might like to write the function in a way that it takes the following inputs:</p>
<ul>
<li><code>j</code>: the discrete choice</li>
<li><code>t</code>: the time period in the model</li>
<li><code>state</code>: a tuple that contains the state <span class="math inline">\((k_\tau,k_\varepsilon,k_\omega)\)</span> as well as a linear indexing rule</li>
<li><code>V</code>: a vector that contains the continuation value for each state at time <span class="math inline">\(t+1\)</span></li>
<li><code>pars</code>: the parameters of the model</li>
<li><code>md</code>: an instance of the model_data object that holds all relevant state variables</li>
</ul>
<p>Verify that your function works by testing it on the <code>model_data</code> instance created by <code>test_model</code>. Use the <code>@time</code> macro to look at evaluation time and memory allocations.</p>
</section>
<section id="part-2" class="level2">
<h2 class="anchored" data-anchor-id="part-2">Part 2</h2>
<p>Write a function called <code>iterate!</code> that iterates over all states at time period <span class="math inline">\(t\)</span> and fills in choice probabilities and continuation values for period <span class="math inline">\(t\)</span> in pre-allocated arrays. Again, you can do this however you like but here is a suggested set of inputs:</p>
<ul>
<li><code>t</code>: the time period</li>
<li><code>logP</code>: a <span class="math inline">\(J \times K \times T\)</span> array of choice probabilities where the function will fill in <code>logP[:,:,t]</code></li>
<li><code>V</code>: a <span class="math inline">\(K \times T\)</span> array of continuation values</li>
<li><code>state_idx</code>: a named tuple that contains the size of the overall state space, a linear indexing rule that maps <span class="math inline">\((k_\tau,k_{\varepsilon},k_{\omega}\)</span>) to an overall state <span class="math inline">\(k\)</span>, and a Cartesian Indexing rule that inverts this mapping</li>
<li><code>vj</code>: a <span class="math inline">\(J\)</span>-dimensional vector that, for each state, can be used as a container for the choice-specific values</li>
<li><code>pars</code>: model parameters</li>
<li><code>md</code>: <code>model_data</code> for the problem</li>
</ul>
<p>Verify that your function works by testing it on the <code>model_data</code> instance created by <code>test_model</code>. Use the <code>@time</code> macro to look at evaluation time and memory allocations.</p>
</section>
<section id="part-3" class="level2">
<h2 class="anchored" data-anchor-id="part-3">Part 3</h2>
<p>Write a function called <code>solve!</code> that performs backward induction to calculate continuation values and choice probabilities (storing them in pre-allocated arrays) in every period of the data across the whole state space. As before, some suggested inputs:</p>
<ul>
<li><code>logP</code>: a <span class="math inline">\(J\times K\times T\)</span> array for choice probabilities</li>
<li><code>V</code>: a <span class="math inline">\(K \times T\)</span> array for continuation values</li>
<li><code>vj</code>: a container or buffer for choice-specific values in each iteration</li>
<li><code>pars</code>: model parameters</li>
<li><code>md</code>: an instance of <code>model_data</code></li>
</ul>
<p>Verify that your function works by testing it on the <code>model_data</code> instance created by <code>test_model</code>. Use the <code>@time</code> macro to look at evaluation time and memory allocations.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>